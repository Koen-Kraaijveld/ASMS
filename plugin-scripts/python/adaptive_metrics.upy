# Dump entity/architecture data using the Understand API

import understand
import statistics

global_report = None


# FREETEXT_KEYS = [
#     "AllowExceptions", "InitValue", "Inline", "Parameters", "Priority",
#     "ThrowExceptions", "AttrArrayComponentSize", "AttrArrayIndexRanges",
#     "AttrComponentFirstBit", "AttrComponentLastBit", "AttrComponentPosition",
#     "AttrRecordAlignment", "AttrTypeSize", "InterruptPriority", "Bitfield",
#     "Linkage", "DefinedInMacro", "UnderlyingType"
# ]
#

def name():
    return "Python Adaptive Metrics"


#
# The following three functions determine when the report is available.
# If ommitted, they're assumed false.
#
def test_global(db):
    """
  Optional method, return true for project level reports
  """
    return True


def test_entity(ent):
    """
  Optional method, return true if report is valid for the entity
  """
    return True


def test_architecture(arch):
    """
  Optional method, return true if report is valid for the architecture
  """
    return True


#
# Optional methods to support abort
#
def support_abort():
    """
  Optional method, return True if this report can be aborted
  """
    return False


def abort():
    """
  Optional method, signal an abort has been requested
  """
    pass


# Progress
def support_proress():
    """
  Optional method indicating if progress is reported

  Report progress with the report.progress(val [,msg]) method.
  """
    return False


# Report Options
def init(report):
    pass


# Report generation
def generate(report, target):
    global_report = report
    starting_tree_depth = 1

    if isinstance(target, understand.Ent):
        method_generate_adaptive_metrics_report(report, target, starting_tree_depth)
    if isinstance(target, understand.Arch):
        set_generate_adaptive_metrics_report(report, target, starting_tree_depth)

    report.print("\n")


# ====================  SET - ADAPTIVE METRICS REPORT  ==================== #

def set_generate_adaptive_metrics_report(report, set, tree_depth):
    print_tree_title(report, "Adaptive Metrics Report (Set)", tree_depth)
    set_generate_concentration_of_control_tree(report, set, tree_depth + 1)
    set_calculate_elementarity_tree(report, set, tree_depth + 1)


def set_generate_concentration_of_control_tree(report, set, tree_depth):
    print_tree_title(report, "Concentration of Control", tree_depth)
    set_calculate_distribution_tree(report, set, tree_depth + 1)


def set_calculate_distribution_tree(report, set, tree_depth):
    print_tree_title(report, "Distribution", tree_depth)

    set_children = set.ents()
    ent_global_control_arr = []
    for ent in set_children:
        ent_global_control_arr.append(calculate_global_control_for_method(report, ent))

    summed_ent_global_control = sum(ent_global_control_arr)

    report.tree(tree_depth + 1, 0)
    report.nobold()
    report.print("Component Sphere of Influence Distribution")

    for i in range(0, len(set_children)):
        distribution = round(ent_global_control_arr[i] / summed_ent_global_control, 2)
        print_mapped_ent_line(report, set_children[i], distribution, tree_depth + 2)

    print_mapped_line(report, "Control Array", ent_global_control_arr, tree_depth + 1)
    print_mapped_line(report, "Variance", statistics.variance(ent_global_control_arr), tree_depth + 1)


def set_calculate_elementarity_tree(report, set, tree_depth):
    print_tree_title(report, "Elementarity", tree_depth)


# ====================  CLASS - ADAPTIVE METRICS REPORT  ==================== #

# def class_generate_adaptive_metrics_report(report, target, tree_depth):

# ====================  METHOD - ADAPTIVE METRICS REPORT  ==================== #

def method_generate_adaptive_metrics_report(report, target, tree_depth):
    print_tree_title(report, "Adaptive Metrics Report (Method)", tree_depth)

    method_generate_locality_tree(report, target, tree_depth + 1)
    method_generate_maintainability_tree(report, target, tree_depth + 1)


def method_generate_maintainability_tree(report, ent, tree_depth):
    print_tree_title(report, "Maintainability", tree_depth)
    method_calculate_testability(report, ent, tree_depth + 1)

    if is_class(ent):
        method_calculate_modifiability(report, ent, tree_depth + 1)


def method_calculate_testability(report, ent, tree_depth):
    print_tree_title(report, "Testability", tree_depth)

    complexity_type = []
    if is_class(ent):
        complexity_type.append("SumCyclomatic")
        complexity_type.append("SumCyclomaticStrict")
    else:
        complexity_type.append("Cyclomatic")
        complexity_type.append("CyclomaticStrict")

    test_case_min = get_metric_from_name(ent, complexity_type[0])
    test_case_max = get_metric_from_name(ent, complexity_type[1])
    print_mapped_line(report, "Minimum Test Case Count", test_case_min, tree_depth + 1,
                      "Number of linearly independent "
                      "paths through the control flow "
                      "graph")
    print_mapped_line(report, "Maximum Test Case Count", test_case_max, tree_depth + 1,
                      "Number of linearly independent "
                      "paths through the control flow "
                      "graph, including paths within the "
                      "conditional expression")


def method_calculate_modifiability(report, ent, tree_depth):
    print_tree_title(report, "Modifiability", tree_depth)

    coupling = get_metric_from_name(ent, "CountClassCoupled")
    print_mapped_line(report, "Coupling", coupling, tree_depth + 1)

    cohesion = get_metric_from_name(ent, "PercentLackOfCohesion")
    print_mapped_line(report, "Cohesion", cohesion, tree_depth + 1)


def method_generate_locality_tree(report, ent, tree_depth):
    print_tree_title(report, "Locality", tree_depth)
    method_calculate_sphere_of_influence(report, ent, tree_depth + 1)


def method_calculate_sphere_of_influence(report, ent, tree_depth):
    print_tree_title(report, "Sphere of Influence", tree_depth)

    local_control = calculate_local_control_for_method(report, ent)
    print_mapped_line(report, "Local", local_control, tree_depth + 1)

    global_control = calculate_global_control_for_method(report, ent)
    print_mapped_line(report, "Global", global_control, tree_depth + 1)


# ===============================  UTILITIES  =============================== #

def get_metric_from_name(ent, name):
    metric = ent.metric((name,))
    return metric[name]


def sum_metrics_from_ent_array(ent_array, metric_name):
    total = 0
    for ent in ent_array:
        metric_val = get_metric_from_name(ent, metric_name)
        if metric_val is not None:
            total += metric_val

    return total


def calculate_local_control_for_method(report, ent):
    if not is_class(ent):
        first_level_called_ent_names = collect_called_func_names(ent, [])
        return sum_metrics_from_ent_array(first_level_called_ent_names, "CountStmtExe")
    else:
        class_funcs = collect_defined_class_funcs(ent)
        class_func_called_arr = []
        for class_func in class_funcs:
            class_func_called_arr.append(class_func)
            collect_called_func_names(class_func, class_func_called_arr)

        return sum_metrics_from_ent_array(class_func_called_arr, "CountStmtExe")


def calculate_global_control_for_method(report, ent):
    total_called_ent_names = collect_total_called_ent_names(report, ent)
    return sum_metrics_from_ent_array(total_called_ent_names, "CountStmtExe")


def sum(array):
    total = 0
    for n in array:
        total += n

    return total


def collect_defined_class_funcs(class_name):
    defined_class_funcs = []

    if refs := class_name.refs():
        for ref in refs:
            kind = ref.kind().longname()
            ref_kind_split = kind.split()
            if ("Define" in ref_kind_split) and (ref.ent() not in defined_class_funcs):
                defined_class_funcs.append(ref.ent())

    return defined_class_funcs


def collect_called_func_names(ent, called_func_names_arr):
    if refs := ent.refs():
        for ref in refs:
            kind = ref.kind().longname()
            ref_kind_split = kind.split()
            ent_kind_split = ref.ent().kind().longname().split()

            if ("Call" in ref_kind_split) and (
                    "Method" in ent_kind_split or "Function" in ent_kind_split) and ref.ent() not in called_func_names_arr:
                called_func_names_arr.append(ref.ent())

    return called_func_names_arr


def collect_total_called_ent_names(report, ent):
    if not is_class(ent):

        total_called_ent_names = collect_called_func_names(ent, [])
        for ent in total_called_ent_names:
            collect_called_func_names(ent, total_called_ent_names)

        return total_called_ent_names

    else:
        class_funcs = collect_defined_class_funcs(ent)
        class_func_called_arr = []
        for class_func in class_funcs:

            class_func_called_arr.append(class_func)
            called_funcs = collect_called_func_names(class_func, class_func_called_arr)
            for called_func in called_funcs:
                collect_called_func_names(called_func, class_func_called_arr)

        return class_func_called_arr


def is_class(ent):
    type_split = ent.kind().name().split()
    return "Class" in type_split


def print_line(report, line, tree_depth, hover_text=None):
    text = str(line)

    report.tree(tree_depth, 1)

    if hover_text:
        report.hover(hover_text)

    report.nobold()
    report.print(text)

    if hover_text:
        report.hover()


def print_mapped_line(report, name, value, tree_depth, hover_text=None):
    text = str(value)

    report.tree(tree_depth, 1)

    if hover_text:
        report.hover(hover_text)

    report.nobold()
    report.print(name + ": ")

    if hover_text:
        report.hover()

    report.bold()
    report.print(text)
    report.nobold()


def print_mapped_ent_line(report, ent, value, tree_depth, hover_text=None):
    text = str(value)

    report.tree(tree_depth, 1)

    if hover_text:
        report.hover(hover_text)

    report.nobold()
    report.entity(ent)
    report.print(ent.name() + ": ")
    report.entity()

    if hover_text:
        report.hover()

    report.bold()
    report.print(text)
    report.nobold()


def print_debug_line(report, debug_info):
    report.fontcolor("red")
    report.nobold()
    report.print("\n")
    report.print(str(debug_info))
    report.print("\n")
    report.fontcolor("black")


def print_tree_title(report, tree_name, tree_depth):
    report.tree(tree_depth, 1)
    report.bold()
    report.print(tree_name)
    report.nobold()


def print_ent_line(report, ent, tree_depth):
    report.tree(tree_depth)
    report.entity(ent)
    report.nobold()
    report.print(ent.simplename())
    report.entity()
